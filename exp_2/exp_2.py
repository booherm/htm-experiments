"""Matt's HTM Experiment 1

	Input --(2D)--> SP --(1D)--> TP --(1D)--> MAN --(2D) ---|
	  ^_____________________________________________________|

	Manipulation function MAN will be decoding the TP output to 2 coordinates, flipping the bit at that location in the input
"""

import exputils
import numpy
import os
import random

os.system("clear")
print "Executing Matt's HTM Experiment 2\n"


#--------------------------------------- setup ----------------------------------

outputImagePrefix = "exp_2_"
outputImageMask = outputImagePrefix + "*.png"
exputils.deleteImages(outputImageMask);
exputils.deleteImages(outputImagePrefix + "*.gif");

inputWidth = 8
inputHeight = 8
input = exputils.getRandom2dBoolMatrix(inputWidth, inputHeight)
generateOutputMovie = True

flatInput = input.flatten()
flatInputLength = len(flatInput)


#--------------------- define transform  -----------------------
def magic(b, c, d):
	if b == 0:
		notb = 1
	else:
		notb = 0
	return (b and c) or (notb and d)

def applyTransform(base, manipulator):
	# This is the heart of the problem.  The transform must be generated by the 
	# order introduced by chaos.  How to kick start this, and how to apply it to the base.
	# the choices it should allow are masks to the input: AND, OR, XOR
	#
	# if input total 0s < 1/2 length, OR
	# if input total 0s > 1/2 length, AND
	# if input total 0s = 1/2 length, XOR
	#ones = numpy.count_nonzero(base)
	#halfLength = flatInputLength / 2
	#if ones < halfLength:
	#	for x in xrange(0, flatInputLength):
	#		base[x] = base[x] or manipulator[x]
	#elif ones > halfLength:
	#	for x in xrange(0, flatInputLength):
	#		base[x] = base[x] and manipulator[x]
	#else:
	#	for x in xrange(0, flatInputLength):
	#		base[x] = base[x] != manipulator[x]
	#for x in xrange(0, flatInputLength):
	#	base[x] = base[x] != manipulator[x]
	#
	groups = flatInputLength / 4
	for group in xrange(0, groups):
		groupBits = flatInput[group * 4 : (group * 4) + 4]
		newGroupBits = [0, 0, 0, 0]
		newGroupBits[0] = magic(b = groupBits[1], c = groupBits[2], d = groupBits[3])
		newGroupBits[1] = magic(b = groupBits[2], c = groupBits[3], d = groupBits[0])
		newGroupBits[2] = magic(b = groupBits[3], c = groupBits[0], d = groupBits[1])
		newGroupBits[3] = magic(b = groupBits[0], c = groupBits[1], d = groupBits[2])
		for b in xrange(0, 4):
			base[(group * 4) + b] = newGroupBits[b]
		
	
			
#--------------------- main loop  -----------------------
transformationVector = exputils.getRandom2dBoolMatrix(inputWidth, inputHeight).flatten()
print "starting main loop"
for cycle in xrange(0, 100):
	#print "Flat input: "
	entropy = exputils.calcEntropy(flatInput)
	print str(cycle) + ": " + exputils.vectorToString(flatInput), "e = " + str(entropy["entropy"]) + " me = " + str(entropy["metricEntropy"])
	unflattenedInput = exputils.unflattenArray(flatInput, inputWidth)
	if generateOutputMovie:
		exputils.writeMatrixImage(unflattenedInput, outputImagePrefix + str(cycle).zfill(5) + ".png")

	#print "Transformed flat input: "
	#print exputils.vectorToString(flatInput)
	applyTransform(flatInput, transformationVector)
	#print exputils.vectorToString(flatInput)

if generateOutputMovie:
	exputils.generateMovie(outputImageMask, outputImagePrefix + "movie.gif")
